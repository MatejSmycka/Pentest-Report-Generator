function replaceAll(source, search, replacement) {
    return source.split(search).join(replacement);
}

function formatImg(imgPath) {
    return `\\includegraphics[scale=0.7]{${imgPath}}`;
}

function formatURL(url) {
    let urlUnderscoreEscaped = replaceAll(url, '_', "\\_");
    return `\\href{${url}}{${urlUnderscoreEscaped}}\\\\`; // ALL urls will have their label set to original URL
}

function texWraping(tex) {
    let output = '<meta charset="UTF-8">\n' +
                 '<title>Generator</title>\n' +
                 '<link rel="stylesheet" href="https://fonts.google.com/specimen/Roboto" />\n' +
                 '<link rel="stylesheet" href="GeneratorStyle.css">' +
                 '<textarea  rows="25" cols="100" style="color:black;">' +
                 `\n${tex}\n` +
                 '</textarea><br><br><br><a href="https://penetration-testing.gitlab-pages.ics.muni.cz/pentest-report-generator/">New finding</a>';
    return output;
}

function formatTex(tex) {
    /* REGEX REPLACING */
    const reg_url = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
    const reg_img = /\.(gif|jpe?g|tiff?|png|webp|bmp)$/i;

    let texFinal = "";
    let listTex = tex.split(/(\s+)/); //split by any whitespace character, whitespace characters will not be erased

    for (i = 0; i < listTex.length; i++) {
        if (listTex[i].match(reg_url)) {
            texFinal += formatURL(listTex[i]) + ' ';
        } else if (listTex[i].match(reg_img)) {
            texFinal += formatImg(listTex[i]) + ' ';
        } else {
            texFinal += listTex[i];
        }
    }
    return texFinal;
}

function TexParser() {
    /* FIELD EVAL. */
    if (cvssScore != "") {
        cvssScore = 'hline Severity: & \\textcolor{' + color + '}{\\textbf{CVSS Score: ' + cvssScore + ' - ' + severity + '}} ' + cvss1 + '\\\\';
    }

    if (impact != "") {
        impact =    'hline Impact: & ' + impact + ' \\\\';
    }

    if (host != "") {
        host =      'hline Hosts: & ' + host + ' \\\\';
    }

    if (role != "") {
        role =      'hline Role: &' + role + ' \\\\';
    }

    if (description != "") {
        description = '\\subsubsection*{Description}\n' + description + '  ';
    }

    if (businessImpact != "") {
        businessImpact = '\\subsubsection*{Bussines impact}\n' + businessImpact + '  ';
    }

    if (remediation != "") {
        remediation = '\\subsubsection*{Remedation}\n' + remediation + '  ';
    }

    if (resources != "") {
        resources = '\\subsubsection*{References}\n' + resources + '  ';
    }
    if (steps != "") {
        /* steps = fieldEscapeSpecialChars(steps) */
        steps = '\\subsubsection*{Steps to reproduce}\n' + steps + '  ';
    }

    //ugly indent to not mess up spacing in final result
    let texOutput = `
\\subsection{${name}}
\\begin{table}[h]
    \\centering
    \\begin{tabular}{|p{0.1\\linewidth} | p{0.85\\linewidth}|} \\rowcolor{${color}}
        \\hline & \\\\
        \\${cvssScore}
        \\${impact}
        \\${host}
        \\${role}
        \\hline
    \\end{tabular}
\\end{table}
\\vspace{-7mm}

${description}

${businessImpact}

${remediation}

${resources}

${steps}
   `;

    return texOutput;
}

/*
    \usepackage[T1]{fontenc} in LATEX should solve this issue, but I will keep code because it might come handy later
    function fieldEscapeSpecialChars(text){
    const characters = ['&', '%', '$', '#', '_', '{', '}', '~', '^', '\'']
    for (const [i, Char] of characters.entries()) {
            text = text.replaceAll(Char, '\\' + Char);
        }

    return text
    }
*/

module.exports = { formatTex,formatURL };
